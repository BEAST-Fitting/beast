from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import numpy as np
from astropy.io import ascii
from astropy.table import Column
from astropy.wcs import WCS

# BEAST imports
import datamodel


def pick_positions(filename,separation,refimage=None):
    """
    Assigns postions to fake star list generated by pick_models

    INPUTS:
    -------

    filename:   string
                Name of AST list generated by pick_models
    separation: float
                Minimum pixel separation between AST and star in photometry 
                catalog provided in the datamodel.
    refimage:   Name of the reference image.  If supplied, the method will use the 
                reference image header to convert from RA and DEC to X and Y.

    OUTPUTS:
    --------

    Ascii table that replaces [filename] with a new version of [filename] that contains the necessary
    position columns for running the ASTs though DOLPHOT
    """

    noise = 3.0 #Spreads the ASTs in a circular annulus of 3 pixel width instead of all being 
                #precisely [separation] from an observed star.

    catalog = datamodel.get_obscat(datamodel.obsfile, datamodel.filters)
    colnames = catalog.data.columns    

    if 'X' or 'x' in colnames:
        if 'X' in colnames:
           x_positions = catalog.data['X'][:]
           y_positions = catalog.data['Y'][:]
        if 'x' in colnames:
           x_positions = catalog.data['x'][:]
           y_positions = catalog.data['y'][:]
    else:
        if refimage:
            if 'RA' or 'ra' in colnames:
                if 'RA' in colnames:
                    ra_positions = catalog.data['RA'][:]
                    dec_positions = catalog.data['DEC'][:]
                if 'ra' in colnames:
                    ra_positions = catalog.data['ra'][:]
                    dec_positions = catalog.data['dec'][:]
            else:
                raise RuntimeError("Your catalog does not supply X, Y or RA, DEC information for spatial AST distribution")

        else:
            raise RuntimeError("You must supply a Reference Image to determine spatial AST distribution.")
        wcs = WCS(refimage)
        x_positions,y_positions = wcs.all_world2pix(ra_positions,dec_positions,0)
 
    astmags = ascii.read(filename)

    n_asts = len(astmags)

    # keep is defined to ensure that no fake stars are put outside of the image boundaries

    keep = (x_positions > np.min(x_positions) + separation + noise) & (x_positions < np.max(x_positions) - separation - noise) & \
           (y_positions > np.min(y_positions) + separation + noise) & (y_positions < np.max(y_positions) - separation - noise)

    x_positions = x_positions[keep]
    y_positions = y_positions[keep]

    ncat = len(x_positions)
    ind = np.random.random(n_asts)*ncat
    ind = ind.astype('int')


    # Here we generate the circular distribution of ASTs surrounding random observed stars
 
    separation = np.random.random(n_asts)*noise + separation
    theta = np.random.random(n_asts) * 2.0 * np.pi
    xvar = separation * np.cos(theta)
    yvar = separation * np.sin(theta)
    
    new_x = x_positions[ind]+xvar; new_y = y_positions[ind]+yvar
    column1 = 0 * new_x
    column2 = column1 + 1
    column1 = Column(name='zeros',data=column1.astype('int'))
    column2 = Column(name='ones',data=column2.astype('int'))
    column3 = Column(name='X',data=new_x,format='%.2f')
    column4 = Column(name='Y',data=new_y,format='%.2f')
    astmags.add_column(column1,0)
    astmags.add_column(column2,1)
    astmags.add_column(column3,2)
    astmags.add_column(column4,3)
    
    ascii.write(astmags,filename,overwrite=True)
    
